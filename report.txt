Eshan Jain - 2020CS50424 ; Si Siddhanth Raja - 2020CS50443

We have defined the state as a string (sentence), a transition as the change of a single character in the string according to the confusion matrix, goal state is the state with the minimum cost of all possible states generated by the transitions.
We have implemented several search algorithms like Vanilla Hill Climbing, Stochastic Hill Climbing, Vanilla Beam Search and several modifications over Hill Climbing. Our best implementation is a modified version of Hill Climbing incorporating random restarts and stochastic transitions. We have commented out all the other versions.

Best Algorithm:
0. In the original confusion matrix, the correct characters are mapped to the possible incorrectly identified characters. Using it, we created an inverse map from the incorrectly recognised characters to the correct ones.
1. We iterate over the characters of the start state (a string) and for every single character we apply all possible transitions according to the inverted confusion matrix. 
The new child states so generated will consist of all possible single character transitions over the start_state. 
2. We choose the minimum cost state among the new states and update our self.best_state to this min state. 
We track the index of the character which has been modified in the best_state as compared to the start_state. This character is final and cannot be further modified in any of the future iterations. This is because we assume that it is the correct character corresponding to the incorrectly recognized character and applying transitions will lead to incorrect states.
3. We repeatedly recurse over our updated best_state and repeat steps 1-2 on the unmodified string indices only.
4. Terminating condition is when there are no more unmodified string indices left i.e. all characters which have possible transitions have been transitioned already.
5. Another terminating condition is when the min state obtained after all possible transitions is the same as the start_state. This may occur if we have already reached goal state without modifying all the characters of the start_state.
6. When the terminating condition is reached, instead of exiting from the program, we perform restart on a randomly sampled state.
If this random restart results in a better state as compared to the our current best state, we update the self.best_state.
7. We finally run steps 1-7 in a loop until the timeout happens. 
This helps us make use of the randomness in the algorithm over multiple runs and escape local minima, if any is reached. 
8. We update the self.best_state to the best possible state reached until timeout.



A Brief Note about our other Algorithms:
1. We also tried implementing a word by word algorithm, which is very similar to our above algorithm, with the slight modification that instead of looking at a letter in every iteration, we look at a word and check all its possible transitions for the minimium cost. 
2. We do this for all words in the state, and update the word with min cost. But this algorithm tended to take a lot of time and hence proved unfruitful.
3. Along similar lines, we tried a triplet word approach where we broke the state (string) into 3 word separate strings. 
4. Then we used our other search algorithms on these strings separately and then combined them together to find the final outout string. Although this algorithm proved to be a bit faster (as we had expected) but it compromised quite a lot on the accuracy so we decided to leave this as well.
